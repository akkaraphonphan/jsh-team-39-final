package uk.ac.ucl.jsh.Parser;

import java.io.ByteArrayOutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import uk.ac.ucl.jsh.Jsh;
import uk.ac.ucl.jsh.antlr.CallParser.*;

/**
 Class that visits ANTLR Generated Abstract Syntax Tree by using the Visitor Pattern generated by ANTLR 
 * and creates the tokens for a CallNode.
 */
public class BuildCallCommand extends CallParserBaseVisitor<ArrayList<String>> {
    @Override 
    /**
     * Visits the compileUnit token from the grammar
     * 
     * @param ctx  ANTLR current parsing context 
     */
    public ArrayList<String> visitCompileUnit(CallParserParser.CompileUnitContext ctx) { 
        return visit(ctx.arguments()); 
    }

    @Override 
    /**
     * Visits an arguments token from the grammar
     * 
     * @param ctx  ANTLR current parsing context 
     */
    public ArrayList<String> visitArguments(CallParserParser.ArgumentsContext ctx) {
        ArrayList<String> result = new ArrayList<>();
        if (ctx.io_operator != null) {
            result.addAll(visit(ctx.cmd));
            result.add(ctx.io_operator.getText());
            result.addAll(visit(ctx.file));
            return result;
        }
        
        result.addAll(visit(ctx.argument()));
        if (ctx.left_arguments != null) {
            result.addAll(visit(ctx.left_arguments));
        }

        return result;
    }

    @Override 
    /**
     * Visits an argument token from the grammar
     * 
     * @param ctx  ANTLR current parsing context 
     */
    public ArrayList<String> visitArgument(CallParserParser.ArgumentContext ctx) {
        ArrayList<String> result = new ArrayList<>();

        if (ctx.quoted() != null) {
            appendArgument(result, visit(ctx.quoted()));
        }
        else {
            appendArgument(result, new ArrayList<>(Arrays.asList(ctx.non_quote.getText())));
        }

        if (ctx.argument() != null) {
            appendArgument(result, visit(ctx.argument()));
        }

        return result;
    }

    @Override 
    /**
     * Visits a quoted token from the grammar
     * 
     * @param ctx  ANTLR current parsing context 
     */
    public ArrayList<String> visitQuoted(CallParserParser.QuotedContext ctx) { 
        return visitChildren(ctx); 
    }
	
    @Override 
    /**
     * Visits a singleQuoted token from the grammar
     * 
     * @param ctx  ANTLR current parsing context 
     */
    public ArrayList<String> visitSingle_quoted(CallParserParser.Single_quotedContext ctx) {
        return new ArrayList<>(List.of(ctx.squote_content().getText()));
    }
	
    @Override 
    /**
     * Visits a doubleQuoted token from the grammar
     * 
     * @param ctx  ANTLR current parsing context 
     */
    public ArrayList<String> visitDouble_quoted(CallParserParser.Double_quotedContext ctx) {
        return visit(ctx.dquote_content());
    }

    @Override 
    /**
     * Visits a doubleQuotedContent token from the grammar
     * 
     * @param ctx  ANTLR current parsing context 
     */
    public ArrayList<String> visitDquote_content(CallParserParser.Dquote_contentContext ctx) { 
        ArrayList<String> result = new ArrayList<>();
        if (ctx.backquoted() != null) {
            appendArgument(result, visit(ctx.backquoted()));
        }
        else if (ctx.content != null) {
            appendArgument(result, new ArrayList<>(Arrays.asList(ctx.content.getText())));
        }

        if (ctx.dquote_content() != null) {
            appendArgument(result, visit(ctx.dquote_content()));
        }

        return result;
    }
	
    @Override 
    /**
     * Visits a backQuoted token from the grammar
     * 
     * @param ctx  ANTLR current parsing context 
     */
    public ArrayList<String> visitBackquoted(CallParserParser.BackquotedContext ctx) { 
        String cmdSubstitutionString = ctx.content.getText();
        if (cmdSubstitutionString == "") {
            return new ArrayList<>(List.of(""));
        }
        
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        Jsh.eval(cmdSubstitutionString, outputStream);

        return new ArrayList<String>(Arrays.asList(outputStream.toString().trim().split(Jsh.lineSeparator)));
    }

    /**
     * Utility function to append an ArrayList to another
     * 
     * @param result      The result of visiting the AST
     * @param arrToAppend The current arguments
     */
    private void appendArgument(ArrayList<String> result, ArrayList<String> arrToAppend) {
        if (result.isEmpty()) {
            result.addAll(arrToAppend);
            return;
        }

        if (arrToAppend.isEmpty()) {
            return;
        }

        result.set(result.size()-1, result.get(result.size()-1) + arrToAppend.get(0));
        result.addAll(arrToAppend.subList(1, arrToAppend.size()));
    }
}